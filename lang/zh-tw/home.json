{
  "hero": "簡單高效作出反應，建構用戶界面。",
  "get_started": "馬上開始",
  "intro_video": "百秒簡介 Solid",
  "intro_video_advanced": "十分鐘詳細介紹",
  "news":
    {
      "content": "快造訪 <b>Solid 商店</b>取得貼紙、 T 恤及更多商品！"
    },
  "strengths": [
    {
      "icon": "performant",
      "label": "性能",
      "description": "始終在使用者介面的速度和記憶體利用率基准測試中名列前茅。"
    },
    {
      "icon": "powerful",
      "label": "強大",
      "description": "可組合的反應式基礎單元，再加上 JSX 的靈活性。"
    },
    {
      "icon": "pragmatic",
      "label": "實用",
      "description": "合理且量身定制的 API 令開發變得有趣而簡單。"
    },
    {
      "icon": "productive",
      "label": "生產力",
      "description": "人因又親切的設計，不管建構簡單或複雜的前端都變得輕而易舉。"
    }
  ],
  "facts": [
    {
      "label": "7kb",
      "detail": "最小化 + Gzip",
      "link": "https://bundlephobia.com/package/solid-js@1.2.1"
    },
    {
      "label": "30k+",
      "detail": "Github stars",
      "link": "https://star-history.t9t.io/#solidjs/solid"
    },
    {
      "label": "5+ 年",
      "detail": "持續開發"
    },
    {
      "label": "TypeScript",
      "detail": "支援"
    },
    {
      "label": "最受好評",
      "detail": "在性能上"
    },
    {
      "label": "Astro & Vite",
      "detail": "支援"
    }
  ],
  "example": {
    "headline": "既親切又現代",
    "copy": [
      "Solid 站在 React, Knockout 等巨人的肩膀上。如果你具備 React 函數式元件及 Hooks 的開發經驗，就會感受到 Solid 的自然，因為它遵循著與 React 相同的哲學——既單一方向資料流、讀寫分離、不可變的介面。",
      "它甚至會讓你感到更加自然，因為 Solid 的更新模型更加簡單且沒有各種要遵循的 Hooks 規則。元件只會執行一次，當元件完成第一次成像後，相關的 Hooks 及繫結都只會在它們的依賴更新時才會重新執行。這是一種全然不同於虛擬 DOM （ Virtual DOM ）的實作。"
    ],
    "link_label": "檢閱文件",
    "link": "https://www.solidjs.com/docs/latest#component-apis"
  },
  "reactivity": {
    "headline": "細微化反應式讓你事半功倍。",
    "subheadline": "Solid 建基於高效的反應式基礎單元，從商業邏輯到 JSX 視圖都適用。",
    "copy": "這種解放使得何者及何時更新得到完全的掌控，即使在 DOM 繫結的層面上也適用。得益於沒有虛擬 DOM 及大量的差異比較下，使得框架從不超過你的意願進行額外的工作。",
    "link_label": "看看實際的例子",
    "link": "https://playground.solidjs.com/?version=1.0.0#NobwRAdghgtgpmAXGGUCWEwBowBcCeADgsrgM4Ae2YZA9gK4BOAxiWGjIbY7gAQi9GcCABM4jXgF9eAM0a0YvAOR0ANmhEBaAFZkA9AHc4AIyUBuADoQOXHv17MhUXHADKaAObRVU2fMUqtOpauuZWVjL0EMy4aLQQvACChIQAFACU-Fa8DvFkfMBQMWgAbnBYvGRwuInFZQC6vAC8Dk4u7l5Qqqm4jPRw6ZYQ2YLVTAkAPCKlDqpQZGRNIEWxZRm8APy8FmArpXA7vIjbYDuSAHwAEmgTetMl51aS4RBCouKp603nvBPJhLw9OcKiJaMx6PAILgAHQeaoAUVUcEhuAAQvgAJIiVJKKApJTpdJWMCSepAA"
  },
  "performance": {
    "headline": ["專注於效能”", "無論是客戶端還是伺服端"],
    "copy": "細微化反應式這一策略在所有著名的基准測試中大放異彩。即使性能不是你的關注點， Solid 帶來的效能提升並不會在 DX （開發者體驗）上帶來額外的複雜度。就把 Solid 的效能提升想成是免費的午餐吧。",
    "link_label": "閱讀全文",
    "link": "https://ryansolid.medium.com/solidjs-the-tesla-of-javascript-ui-frameworks-6a1d379bc05e"
  },
  "features": {
    "headline": "滿載所有功能。",
    "copy": "Solid 支援並滿足現代化函式庫所期待的功能，甚至某些功能還有更好的 DX 。",
    "list": [
      "Fragments",
      "Portals",
      "Context",
      "Suspense",
      "Error Boundaries",
      "Lazy Components",
      "Async & Concurrent Rendering",
      "Implicit Delegation",
      "SSR & Hydration",
      "Directives",
      "Streaming"
    ]
  },
  "benchmarks": {
    "time": "時間",
    "view": "檢視基準測試",
    "show_more": "顯示更多客戶端及伺服端的基準測試",
    "link_label": "針對 JS 框架橫跨大量測試比較瀏覽器效能的基準測試。數值越低越好。",
    "js_benchmark": {
      "title": "JS 框架基準測試",
      "description": "針對 JS 框架橫跨大量測試比較瀏覽器效能的基準測試。數值越低越好。"
    },
    "isomorophic_benchmark": {
      "title": "同構 UI 基準測試（搜尋結果為例）",
      "description": "此項基准測試測試原生伺服器成像速度。數值越高越好。"
    }
  }
}
